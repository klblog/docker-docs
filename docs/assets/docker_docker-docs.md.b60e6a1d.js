import{_ as o,o as e,c as n,a,S as l,k as s}from"./chunks/framework.43b881fd.js";const t="/docs/assets/docker-desktop.c09af20e.png",b=JSON.parse('{"title":"1. 基本概念","description":"","frontmatter":{},"headers":[],"relativePath":"docker/docker-docs.md","filePath":"package/docker/docker-docs.md"}'),c={name:"docker/docker-docs.md"},p=l('<h1 id="_1-基本概念" tabindex="-1">1. 基本概念 <a class="header-anchor" href="#_1-基本概念" aria-label="Permalink to &quot;1. 基本概念&quot;">​</a></h1><h2 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h2><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p></blockquote><blockquote><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销，可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架或包装系统。</p></blockquote><blockquote><p>推荐学习地址：<a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noreferrer">!Dcoker 从入门到实践</a></p></blockquote><h2 id="一、什么是docker" tabindex="-1">一、什么是Docker <a class="header-anchor" href="#一、什么是docker" aria-label="Permalink to &quot;一、什么是Docker&quot;">​</a></h2><h3 id="_1、讲个故事" tabindex="-1">1、讲个故事： <a class="header-anchor" href="#_1、讲个故事" aria-label="Permalink to &quot;1、讲个故事：&quot;">​</a></h3><br>',8),r=s("br",null,null,-1),i=s("br",null,null,-1),d=s("br",null,null,-1),C=l('<h3 id="_2、虚拟机和容器" tabindex="-1">2、虚拟机和容器 <a class="header-anchor" href="#_2、虚拟机和容器" aria-label="Permalink to &quot;2、虚拟机和容器&quot;">​</a></h3><h4 id="_1、虚拟机-virtual-machine" tabindex="-1">1、虚拟机（<code>Virtual Machine</code>） <a class="header-anchor" href="#_1、虚拟机-virtual-machine" aria-label="Permalink to &quot;1、虚拟机（`Virtual Machine`）&quot;">​</a></h4><ul><li>虚拟化的硬件，通过软件来模拟的具有独立完整硬件系统功能，且运行在一个完全隔壁环境中的完整计算机系统。在实体计算机能够完成的工作在虚拟机中也可以完成。</li><li>在计算机中创建虚拟机需要把计算机的部分硬盘、内存容量作为虚拟机的硬盘、内存容量。每个虚拟机都有独立的CMOS 、硬盘和操作系统，我们可以想使用计算机一样使用它。</li><li>常见虚拟机有：<code>VMWare</code> 、<code>OpenStack</code></li></ul><h4 id="_2、容器" tabindex="-1">2、容器 <a class="header-anchor" href="#_2、容器" aria-label="Permalink to &quot;2、容器&quot;">​</a></h4><ul><li>把操作系统虚拟化，是一个标准的软件单元</li><li>随时随地运行：容器可以把软件代码、配置文件、相关依赖进行打包，从而确保可以在任何环境下运行。</li><li>高资源的利用率：容器提供进程级别的隔离，可以精细化的设置CPU和内存的使用率，从而更好的利用计算机资源。</li><li>快速启动：每个容器都可以作为单独的进程予以运行，并且在共享底层操作系统的资源，从而加快容器的启动和停止效率。</li></ul><h4 id="_3、虚拟机和容器区别" tabindex="-1">3、虚拟机和容器区别 <a class="header-anchor" href="#_3、虚拟机和容器区别" aria-label="Permalink to &quot;3、虚拟机和容器区别&quot;">​</a></h4><ul><li>虚拟机虽然可以隔离出多个子电脑，但是占空间大、启动速度慢，而且部分收费。</li><li>容器不需要虚拟出一个操作系统，只需要虚拟出一个很小的运行环境，类似于沙盒。</li><li>容器的运行空间不需要虚拟出整个操作系统，通常虚拟机大小在几GB到几十GB之间，而容器的大小在几KB到几十MB之间</li></ul><h4 id="_4、区别明细" tabindex="-1">4、区别明细 <a class="header-anchor" href="#_4、区别明细" aria-label="Permalink to &quot;4、区别明细&quot;">​</a></h4><table><thead><tr><th>特点</th><th>虚拟机</th><th>容器</th></tr></thead><tbody><tr><td>隔离级别</td><td>操作系统级别</td><td>进程级别</td></tr><tr><td>隔离策略</td><td>虚拟监控机</td><td>控制群组</td></tr><tr><td>系统资源</td><td>5%-15%</td><td>0-5%</td></tr><tr><td>镜像大小</td><td>GB-TB</td><td>KB-MB</td></tr><tr><td>启动速度</td><td>分钟</td><td>秒</td></tr><tr><td>集群规模</td><td>上百</td><td>上万</td></tr></tbody></table><h2 id="二、docker-核心概念" tabindex="-1">二、Docker 核心概念 <a class="header-anchor" href="#二、docker-核心概念" aria-label="Permalink to &quot;二、Docker 核心概念&quot;">​</a></h2><ul><li>三大核心：镜像<code>Image</code>、容器<code>Container</code>、仓库<code>Repository</code></li><li>阶段：构建<code>Build</code>、运输<code>Ship</code>、运行<code>Run</code></li><li>Docker 本身不是容器，它是应用容器引擎，而镜像是容器的基础，容器是镜像的运行实例</li><li>一次搭建、处处运行</li><li>Docker 技术使用 <code>Linux</code> 内核功能（<code>Cgroups</code>和<code>Namespace</code>）来隔离进程，以便各个进程之间可以不受到影响</li><li>由于<code>Cgroups</code>和 <code>Namespace</code> 技术只存在<code>Linux</code>内核上，那容器无法运行在其他操作系统上，那在<code>Macos</code>和<code>windows</code>上如何运行呢？其实<code>Docker</code>在非<code>Linux</code>上会安装一个<code>Linux</code>虚拟机，而容器跑在这个虚拟机上。</li><li>镜像：它是一个可执行的包，包含了执行时的代码、配置文件、依赖文件等</li></ul><h2 id="三、安装使用docker" tabindex="-1">三、安装使用Docker <a class="header-anchor" href="#三、安装使用docker" aria-label="Permalink to &quot;三、安装使用Docker&quot;">​</a></h2><h3 id="_1、命令行安装" tabindex="-1">1、命令行安装 <a class="header-anchor" href="#_1、命令行安装" aria-label="Permalink to &quot;1、命令行安装&quot;">​</a></h3><p><strong>在Mac中利用Homebrew</strong></p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">brew</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">cask</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span></span></code></pre></div><h3 id="_2、查看版本" tabindex="-1">2、查看版本 <a class="header-anchor" href="#_2、查看版本" aria-label="Permalink to &quot;2、查看版本&quot;">​</a></h3><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-v</span></span></code></pre></div><h3 id="_3、安装桌面端-可省略-但是强烈建议" tabindex="-1">3、安装桌面端（可省略，但是强烈建议） <a class="header-anchor" href="#_3、安装桌面端-可省略-但是强烈建议" aria-label="Permalink to &quot;3、安装桌面端（可省略，但是强烈建议）&quot;">​</a></h3><ul><li>安装地址：<a href="https://www.docker.com/" target="_blank" rel="noreferrer">https://www.docker.com/</a></li><li>安装后： <img src="'+t+`" alt="alt"></li></ul><h3 id="_4、配置镜像源加速" tabindex="-1">4、配置镜像源加速 <a class="header-anchor" href="#_4、配置镜像源加速" aria-label="Permalink to &quot;4、配置镜像源加速&quot;">​</a></h3><p><strong>默认情况下，Docker 使用 Docker Hub 作为官方的默认镜像源。但是，如果你在中国或其他地区使用 Docker，可能会遇到下载速度较慢的问题，这时你可以配置国内的镜像源地址来加速下载。</strong></p><ul><li>如果你没安装 Docker Desktop for Mac 可以通过终端配置：</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 1、打开Docker 配置文件</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">sudo</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">nano</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/etc/docker/daemon.json</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;"># 2、配置文件中加入</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">&quot;registry-mirrors&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#A6ACCD;"> [</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#FFCB6B;">&quot;http://hub-mirror.c.163.com/&quot;</span><span style="color:#FFCB6B;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#FFCB6B;">&quot;https://registry.docker-cn.com&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">      ],</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">&quot;insecure-registries&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#A6ACCD;">[],</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">&quot;experimental&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false</span><span style="color:#C3E88D;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">&quot;debug&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;"># 重启Docker</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">sudo</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">systemctl</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">restart</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span></span></code></pre></div><ul><li>如果安装了Docker桌面端，可以在Docker的 Setting -&gt; Docker Engine 中加入上述配置</li></ul><h2 id="四、docker-常见指令" tabindex="-1">四、Docker 常见指令 <a class="header-anchor" href="#四、docker-常见指令" aria-label="Permalink to &quot;四、Docker 常见指令&quot;">​</a></h2><p><strong>安装Docker后我们先从如何构建镜像学起，构建镜像需要先知道以下指令</strong></p><h3 id="_1、基本指令" tabindex="-1">1、基本指令 <a class="header-anchor" href="#_1、基本指令" aria-label="Permalink to &quot;1、基本指令&quot;">​</a></h3><table><thead><tr><th>指令名</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>基于哪个镜像来实现</td></tr><tr><td>MAINTAINER</td><td>镜像作者</td></tr><tr><td>as</td><td>给构建过程的阶段一个标识，通常用在多阶段构建，用来标识不同的构建阶段，方便在后续阶段的操作中引入改阶段</td></tr><tr><td>WORKDIR</td><td>工作目录</td></tr><tr><td>ENV</td><td>声明环境变量</td></tr><tr><td>ADD</td><td>把宿主机的文件复制到容器中，压缩文件会自动解压</td></tr><tr><td>COPY</td><td>和COPY功能类似，实现复制功能，但是压缩文件不会自动解压</td></tr><tr><td>RUN</td><td>需要运行的命令</td></tr><tr><td>CMD</td><td>容器启动时(docker run)需要的指令，如果执行 docker run + 指令会覆盖掉CMD中的</td></tr><tr><td>EXPORT</td><td>容器内可以使用的端口</td></tr><tr><td>VOLUMN</td><td>数据卷，把宿主机目录影响到容器中的目录</td></tr></tbody></table><h3 id="_2、构建镜像" tabindex="-1">2、构建镜像 <a class="header-anchor" href="#_2、构建镜像" aria-label="Permalink to &quot;2、构建镜像&quot;">​</a></h3><ul><li>基础指令： docker build [OPTIONS] PATH <br></li><li>OPTIONS有哪些配置项： <br></li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">-t</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 指定镜像名称和标签</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">-f</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 指定要使用的 Dockerfile 文件路径，如果你的Dockerfile配合文件不在的当前目录</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">--build-arg</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 设置构建过程中的构建参数，在Dockerfile中可以通过 ARG 来声明接受构建参数</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">--target</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 用于在多阶段构建中指定目标构建阶段的名称， 多阶段构建时，可以使用 AS 关键字给不同的构建阶段命名，并通过 --target 参数来指定构建的目标阶段。</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">--no-cache</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 强制Docker不使用缓存，从头到尾构建</span></span></code></pre></div><ul><li>例如：</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># .代表Dockerfile配置文件在当前目录，构建了一个my_images:my-image-tag 的镜像</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">build</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-t</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_images:latest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># 配置文件在Dockerfile目录下，构建参数是ENVIRONMENT=production，不使用缓存</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">build</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-t</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">my_images:my-image-tag</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-f</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Dockerfile</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--build-arg</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ENVIRONMENT=production</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--no-cache</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span></span></code></pre></div><ul><li>查看构建好的镜像</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">image</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ls</span></span></code></pre></div><h3 id="_3、运输镜像" tabindex="-1">3、运输镜像 <a class="header-anchor" href="#_3、运输镜像" aria-label="Permalink to &quot;3、运输镜像&quot;">​</a></h3><p><strong>构建好的镜像可以保存在本地或上传到Docker hub或其他镜像仓库</strong></p><h4 id="打包成压缩文件" tabindex="-1">打包成压缩文件 <a class="header-anchor" href="#打包成压缩文件" aria-label="Permalink to &quot;打包成压缩文件&quot;">​</a></h4><ul><li>保存镜像为 tar 文件：</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">save</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-o</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my-image.tar</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my-image:latest</span></span></code></pre></div><ul><li>加载 tar 文件中的镜像：</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">load</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-i</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my-image.tar</span></span></code></pre></div><h4 id="上传到-docker-hub" tabindex="-1">上传到 Docker Hub <a class="header-anchor" href="#上传到-docker-hub" aria-label="Permalink to &quot;上传到 Docker Hub&quot;">​</a></h4><ul><li>登录 Docker Hub：</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">login</span></span></code></pre></div><ul><li>在Docker Hub 中创建一个空间（<code>Namespace</code>）、仓库（<code>repository</code> 可以先不用创建），例如创建另一个名为 <code>copymanager</code> 空间</li><li>给待上传的镜像打标签</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">tag</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">local_image_name:tagname</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">copymanager/local_image_name:tagname</span></span></code></pre></div><ul><li>上传：</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">push</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">copymanager/local_image_name:tag</span></span></code></pre></div><h4 id="上传到私有镜像仓库" tabindex="-1">上传到私有镜像仓库 <a class="header-anchor" href="#上传到私有镜像仓库" aria-label="Permalink to &quot;上传到私有镜像仓库&quot;">​</a></h4><ol><li>搭建私有镜像仓库：需要搭建自己的私有镜像仓库，比较常用的有 Docker Regisry，Harbor等。这些镜像仓库允许你在公司内部创建并管理空间，上传和管理镜像，并设置权限。</li><li>登录私有镜像仓库：上传镜像前需要先登录</li></ol><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">login</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">your_private_registory_url</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--username</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">xxx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--password</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">xxx</span></span></code></pre></div><ol start="3"><li>上传镜像:</li></ol><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">tag</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">local_image_name:tagname</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">copymanager/local_image_name:tagname</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 也可以在构建docker时直接构建成名为 copymanager/local_image_name:tagname 的镜像，例如：docker build copymanager/local_image_name:tagname .</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">push</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">copymanager/local_image_name:tagname</span></span></code></pre></div><h3 id="_4、启动或运行容器" tabindex="-1">4、启动或运行容器 <a class="header-anchor" href="#_4、启动或运行容器" aria-label="Permalink to &quot;4、启动或运行容器&quot;">​</a></h3><ul><li>常用指令</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 基本指令</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-d</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-p</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3005</span><span style="color:#C3E88D;">:3000</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">local_image_name</span></span></code></pre></div><ul><li>其他指令 <ol><li><code>--name &lt;容器名称&gt;</code>：给容器指定一个名称。例如：<code>--name my_image</code>，将容器命名为 my_image，方便对容器的操作。</li><li><code>-e &lt;环境变量&gt;</code>：设置环境变量。例如：<code>-e MYSQL_ROOT_PASSWORD=mysecretpassword</code>，将在容器中设置一个名为MYSQL_ROOT_PASSWORD的环境变量，值为mysecretpassword。</li><li><code>--volume &lt;宿主机路径&gt;:&lt;容器内部路径&gt;</code>：设置数据卷，把宿主机目录挂载到容器目录。例如：<code>--volumn /Users/baixing/Desktop/baixing-workspace/chato-www-ts/dist:/usr/share/nginx/html</code>， 将宿主机的/Users/baixing/Desktop/baixing-workspace/chato-www-ts/dist目录挂载到容器内的/usr/share/nginx/html目录下，这样容器就可以读或写宿主机目录下的文件。</li><li><code>--restart &lt;重启策略&gt;</code>，指定容器的重启策略。例如：<code>--restart always</code>表示容器退出时重启</li><li><code>--env-file &lt;环境变量文件&gt;</code>，从指定文件中读取环境变量。例如：<code>--env-file my_env.txt</code>，会读取名为 my_env.txt 的文件中的环境变量，并在容器中设置这些环境变量。</li><li><code>--network &lt;网络模式&gt;</code>：指定容器的网络模式。例如：<code>--network host</code>，使用宿主机的网络命名空间，使得宿主机和容器共享网络。其他网络模式还有 <code>bridge</code> 和 <code>none</code></li></ol><ul><li>bridge（默认模式）： <ul><li>这是默认的网络模式，Docker 容器默认会使用一个名为 &quot;bridge&quot; 的虚拟网络桥接到主机的网络接口。</li><li>容器之间可以通过 IP 地址相互通信，但是对于主机和外部网络来说，容器的 IP 地址是不可见的。需要使用端口映射（-p 参数）来将容器的端口映射到主机的端口，以便外部网络访问容器服务。</li><li>每个容器在这个网络模式下都有一个唯一的 IP 地址。</li><li>如何查看容器ip 地址：</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ps</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 查看当前正在运行的容器</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">inspect</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-f</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">容器名称或容器I</span><span style="color:#A6ACCD;">D</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 特定容器的 IP 地址</span></span></code></pre></div></li><li>host： <ul><li>在 --network host 模式下，容器与主机共享网络命名空间，容器使用主机的网络栈。这意味着容器不再拥有自己的网络命名空间，而是直接使用主机的网络接口。</li><li>容器可以直接访问主机上的服务，容器的端口将与主机上的端口绑定，无需映射端口。</li><li>这种模式下，容器的网络性能会较好，但容器之间的网络隔离性较差。</li></ul></li><li>none： <ul><li>在 --network none 模式下，容器没有自己的网络栈，完全与外部网络隔离。这意味着容器不能通过网络与外部通信，也不能通过 IP 地址访问容器。</li><li>这种模式下适用于特定的场景，例如需要在容器中运行应用程序，但不需要网络功能。</li></ul></li><li>例如： <a href="https://github.com/lik778/Docker-Learn/blob/master/python/README.md" target="_blank" rel="noreferrer">host网络模式demo</a></li></ul><ol start="7"><li><code>-it</code>，以交互式模式运行容器，并为容器分配一个伪终端，以便你可以与容器进行交互。例如：<code>docker run -it -p 3005:3000 local_image_name</code></li><li><code>-d</code>，后台运行容器，也称为“分离模式”。使用 -d 参数后，容器会在后台运行，不会将容器的输出打印到终端，并且会返回容器的ID</li></ol></li></ul><h3 id="_5、其他指令" tabindex="-1">5、其他指令 <a class="header-anchor" href="#_5、其他指令" aria-label="Permalink to &quot;5、其他指令&quot;">​</a></h3><h4 id="镜像相关" tabindex="-1">镜像相关 <a class="header-anchor" href="#镜像相关" aria-label="Permalink to &quot;镜像相关&quot;">​</a></h4><ul><li><code>docker pull nginx</code>：下载远程镜像到本地</li><li><code>docker rmi image_name</code>：删除本地镜像</li><li><code>docker tag local_image_name:tagname new_image_name:tagname</code>：为本地镜像打标签</li><li><code>docker images</code>：列出本地镜像</li><li><code>docker push xxx</code>：推送本地镜像到镜像仓库</li></ul><h4 id="容器相关" tabindex="-1">容器相关 <a class="header-anchor" href="#容器相关" aria-label="Permalink to &quot;容器相关&quot;">​</a></h4><ul><li><code>docker ps</code>：查看当前正在运行的容器</li><li><code>docker ps -a</code>：查看所有的容器，包含暂停的</li><li><code>docker start 容器名/CONTAINER ID</code>：启动已经创建的容器</li><li><code>docker stop 容器名/CONTAINER ID</code>：停止运行容器</li><li><code>docker rm 容器名/CONTAINER ID</code>：删除已经停止的容器</li><li><code>docker exec 指令</code>：在正在运行的容器中执行命令</li><li><code>docker logs 容器名/CONTAINER ID</code>：查看容器的日志</li><li><code>docker inspect 容器名/CONTAINER ID</code>：查看容器详细信息</li></ul><h4 id="网络相关指令-容器通信、隔离网络、多容器应用" tabindex="-1">网络相关指令（容器通信、隔离网络、多容器应用） <a class="header-anchor" href="#网络相关指令-容器通信、隔离网络、多容器应用" aria-label="Permalink to &quot;网络相关指令（容器通信、隔离网络、多容器应用）&quot;">​</a></h4><ul><li><code>docker network ls</code>：列出 Docker 网络</li><li><code>docker network create my_network(网络名)</code>：创建 Docker 网络</li><li><code>docker network connect my_network(网络名) my_container(容器名/CONTAINER ID)</code>：将容器连接到指定的 Docker 网络</li><li><code>docker network disconnect my_network(网络名) my_container(容器名/CONTAINER ID)</code>：将容器从指定的 Docker 网络断开连接</li><li>扩展：在下面的示例中，我们创建了一个名为 my_network 的自定义网络，并将两个容器 app_container 和 db_container 连接到该网络。这样，这两个容器就可以直接通过容器名称 app_container 和 db_container 进行通信，而不需要使用端口映射。</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">network</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">create</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_network</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-d</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--name</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">app_container</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--network</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_network</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_app_image</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-d</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--name</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">db_container</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--network</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_network</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_db_image</span></span></code></pre></div><h4 id="数据卷相关指令" tabindex="-1">数据卷相关指令 <a class="header-anchor" href="#数据卷相关指令" aria-label="Permalink to &quot;数据卷相关指令&quot;">​</a></h4><ul><li><code>docker volume ls</code>：列出 Docker 数据卷</li><li><code>docker volume create my_volume(数据卷名)</code>：创建 Docker 数据卷</li><li><code>docker inspect my_volume(数据卷名)</code>：查看创建的数据券地址</li><li><code>docker volume rm my_volume(数据卷名)</code>：删除 Docker 数据卷</li><li>扩展：my_volume 数据卷被挂载到了/app/data路径上。这意味着容器内的/app/data目录中的内容实际上是与主机上名为my_volume的数据卷相关联的目录。容器对/app/data的任何更改都将保存在主机上，即使容器被删除，数据卷上的数据也不会丢失</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">volume</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">create</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_volume</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-d</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--name</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_container</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-v</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_volume:/app/data</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">my_image</span></span></code></pre></div><h4 id="其他常用指令" tabindex="-1">其他常用指令： <a class="header-anchor" href="#其他常用指令" aria-label="Permalink to &quot;其他常用指令：&quot;">​</a></h4><ul><li><code>docker info</code>: 显示 Docker 系统信息。</li><li><code>docker version</code>: 显示 Docker 版本信息。</li><li><code>docker search</code>: 在 Docker Hub 中搜索镜像。</li><li><code>docker login</code>: 登录到 Docker Hub 或者其他 Docker 仓库。</li><li><code>docker logout</code>: 登出 Docker Hub 或者其他 Docker 仓库。</li></ul>`,71);function y(D,h,A,u,k,m){return e(),n("div",null,[p,a(" 假如我们要盖一所房子，可能需要先画图纸、打地基、搬砖砌墙，一顿操作终于改好了。 "),r,a(" 如果我们住了一段时间，有一天，突然心血来潮想搬到海边去，没办法，我们只能再次画图纸、打地基、搬砖砌墙。 "),i,a(" 正在我们烦恼之际，突来有种魔法，它可以把我们的房子复制一份，做成一个镜像，直接放在书包里面，到了海边，我们直接把房子从书包里面拿出来就可以，实现拎包入住。 "),d,a(" 是不是很神奇，应用到我们项目中来，房子就是项目本身，镜像就是项目的复制，背包就是镜像的仓库。我们直接从镜像仓库中取出镜像可以应用在任何地方。 "),C])}const _=o(c,[["render",y]]);export{b as __pageData,_ as default};
